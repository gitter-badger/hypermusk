// Generated by github.com/hypermusk/hypermusk
// DO NOT EDIT


#import "api.h"

static Api * _api;
static NSDateFormatter * _dateFormatter;

@implementation NSData (NSString)
- (NSString *) asUTF8String {
    return [[NSString alloc] initWithData:self encoding:NSUTF8StringEncoding];
}
@end

@implementation Api : NSObject
+ (Api *) get {
	if(!_api) {
		_api = [[Api alloc] init];
		if ([_api requestTimeoutInterval] == 0) {
			[_api setRequestTimeoutInterval:10];
		}
	}
	return _api;
}

+ (NSDateFormatter *) dateFormatter {
	if(!_dateFormatter) {
		_dateFormatter = [[NSDateFormatter alloc] init];
		[_dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZ"];
	}
	return _dateFormatter;
}

+ (NSDate *) dateFromString:(NSString *)dateString {
	if(!dateString) {
		return nil;
	}

	NSError *error;
	NSRegularExpression *regexp = [NSRegularExpression regularExpressionWithPattern:@"\\.[0-9]*" options:0 error:&error];
	NSAssert(!error, @"Error in regexp");

	NSRange range = NSMakeRange(0, [dateString length]);
	dateString = [regexp stringByReplacingMatchesInString:dateString options:0 range:range withTemplate:@""];

	NSDate *date;
	[[Api dateFormatter] getObjectValue:&date forString:dateString range:nil error:&error];
	if(error) {
		if ([[Api get] verbose]) NSLog(@"Error formatting date %@: %@ (%@)", dateString, [error localizedDescription], error);
		return nil;
	}
	return date;
}

+ (NSString *) stringFromDate:(NSDate *) date {
	if(!date) {
		return nil;
	}
	NSString * dateString = [[Api dateFormatter] stringFromDate:date];
	dateString = [[[dateString substringToIndex:(dateString.length - 3)] stringByAppendingString:@":"] stringByAppendingString:[dateString substringFromIndex:(dateString.length - 2)]];
	return dateString;
}



+ (NSDictionary *) request:(NSURL*)url
		params:(NSDictionary *)params
		stream:(NSInputStream*)stream
		error:(NSError **)error
		completionHandler:(void (^)(NSDictionary *results, NSError *error))completionHandler
{

	Api * _api = [Api get];
	NSMutableURLRequest *httpRequest = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:[_api requestTimeoutInterval]];

	[httpRequest setHTTPMethod:@"POST"];
	NSData *requestBody;
	if (stream == nil) {
		[httpRequest setValue:@"application/json;charset=utf-8" forHTTPHeaderField:@"Content-Type"];
		requestBody = [NSJSONSerialization dataWithJSONObject:params options:NSJSONWritingPrettyPrinted error:error];
		[httpRequest setHTTPBody:requestBody];
	} else {
		[httpRequest setValue:@"application/octet-stream" forHTTPHeaderField:@"Content-Type"];
		requestBody = [NSJSONSerialization dataWithJSONObject:params options:0 error:error];
		NSData *base64RequestBodyData = [requestBody base64EncodedDataWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
		NSString *paramBase64 = [[NSString alloc ] initWithBytes: [base64RequestBodyData bytes] length:[base64RequestBodyData length] encoding:NSUTF8StringEncoding];

		[httpRequest setValue:paramBase64 forHTTPHeaderField:@"X-HyperMuskStreamParams"];
		[httpRequest setHTTPBodyStream:stream];
	}
	[httpRequest setValue:@"gzip, deflate" forHTTPHeaderField:@"Accept-Encoding"];

	if([_api verbose]) {
		NSLog(@"Request: %@", [requestBody asUTF8String]);
	}

	if(*error != nil) {
		return nil;
	}

	if (completionHandler == nil) {
		NSURLResponse  *response = nil;
		NSData *returnData = [NSURLConnection sendSynchronousRequest:httpRequest returningResponse:&response error:error];
		if(*error != nil || returnData == nil) {
			return nil;
		}
		if([_api verbose]) {
			NSLog(@"Response: %@", [returnData asUTF8String]);
		}
		return [NSJSONSerialization JSONObjectWithData:returnData options:NSJSONReadingAllowFragments error:error];
	}

	NSOperationQueue *queue = [[NSOperationQueue alloc] init];
	[NSURLConnection sendAsynchronousRequest:httpRequest
				queue:queue
				completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
					NSError *blockError = nil;
					if([_api verbose]) {
						NSLog(@"Response: %@", [data asUTF8String]);
					}

					NSDictionary *results = nil;

					if (connectionError) {
					    NSLog(@"Connection Error: %@", connectionError);
					    blockError = connectionError;
					} else if (data) {
					    results = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&blockError];
					    if (blockError) NSLog(@"Error decoding JSON: %@", blockError);
					}

					dispatch_async(dispatch_get_main_queue(), ^{
					    completionHandler(results, blockError);
					});
				}];
	return nil;

}



+ (NSError *)errorWithDictionary:(NSDictionary *)dict {
	if (![dict isKindOfClass:[NSDictionary class]]) {
		return nil;
	}
	if ([[dict allKeys] count] == 0) {
		return nil;
	}
	NSMutableDictionary *userInfo = [NSMutableDictionary alloc];
	id reason = [dict valueForKey:@"Reason"];
	if ([reason isKindOfClass:[NSDictionary class]]) {
		userInfo = [userInfo initWithDictionary:reason];
	} else {
		userInfo = [userInfo init];
	}
	[userInfo setObject:[dict valueForKey:@"Message"] forKey:NSLocalizedDescriptionKey];

	NSString *code = [dict valueForKey:@"Code"];
	NSNumberFormatter *f = [[NSNumberFormatter alloc] init];
	[f setNumberStyle:NSNumberFormatterDecimalStyle];
	NSNumber *codeNumber = [f numberFromString:code];
	NSInteger intCode = -1;
	if (codeNumber != nil) {
		intCode = [codeNumber integerValue];
	}
	NSError *err = [NSError errorWithDomain:@"ApiError" code:intCode userInfo:userInfo];
	return err;
}

@end


// --- UseMap ---
@implementation UseMap

- (id) initWithDictionary:(NSDictionary*)dict{
	self = [super init];
	if (!self) {
		return self;
	}
	if (![dict isKindOfClass:[NSDictionary class]]) {
		return self;
	}
	[self setMap:[dict valueForKey:@"Map"]];

	return self;
}

- (id)initWithCoder:(NSCoder *)decoder {
    NSDictionary *dict = [decoder decodeObjectForKey:@"dict"];

    self = [self initWithDictionary:dict];

    return self;
}

- (void)encodeWithCoder:(NSCoder *)encoder {
    [encoder encodeObject:[self dictionary] forKey:@"dict"];
}

- (NSDictionary*) dictionary {
	NSMutableDictionary * dict = [[NSMutableDictionary alloc] init];
	[dict setValue:self.map forKey:@"Map"];

	return dict;
}

@end


// === Interfaces ===



// --- AuthorizeParams ---
@implementation ServiceAuthorizeParams : NSObject

- (id) initWithDictionary:(NSDictionary*)dict{
	self = [super init];
	if (!self) {
		return self;
	}
	if (![dict isKindOfClass:[NSDictionary class]]) {
		return self;
	}
	[self setName:[dict valueForKey:@"Name"]];

	return self;
}

- (id)initWithCoder:(NSCoder *)decoder {
    NSDictionary *dict = [decoder decodeObjectForKey:@"dict"];

    self = [self initWithDictionary:dict];

    return self;
}

- (void)encodeWithCoder:(NSCoder *)encoder {
    [encoder encodeObject:[self dictionary] forKey:@"dict"];
}

- (NSDictionary*) dictionary {
	NSMutableDictionary * dict = [[NSMutableDictionary alloc] init];
	[dict setValue:self.name forKey:@"Name"];

	return dict;
}

@end

// --- AuthorizeResults ---
@implementation ServiceAuthorizeResults : NSObject

- (id) initWithDictionary:(NSDictionary*)dict{
	self = [super init];
	if (!self) {
		return self;
	}
	if (![dict isKindOfClass:[NSDictionary class]]) {
		return self;
	}

	id dictUseMap = [dict valueForKey:@"UseMap"];
	if ([dictUseMap isKindOfClass:[NSDictionary class]]){
		[self setUseMap:[[UseMap alloc] initWithDictionary:dictUseMap]];
	}
	[self setErr:[Api errorWithDictionary:[dict valueForKey:@"Err"]]];

	return self;
}

- (id)initWithCoder:(NSCoder *)decoder {
    NSDictionary *dict = [decoder decodeObjectForKey:@"dict"];

    self = [self initWithDictionary:dict];

    return self;
}

- (void)encodeWithCoder:(NSCoder *)encoder {
    [encoder encodeObject:[self dictionary] forKey:@"dict"];
}

- (NSDictionary*) dictionary {
	NSMutableDictionary * dict = [[NSMutableDictionary alloc] init];
	[dict setValue:[self.useMap dictionary] forKey:@"UseMap"];
	
	[dict setValue:self.err forKey:@"Err"];

	return dict;
}

@end

// --- PermiessionDeniedParams ---
@implementation ServicePermiessionDeniedParams : NSObject

- (id) initWithDictionary:(NSDictionary*)dict{
	self = [super init];
	if (!self) {
		return self;
	}
	if (![dict isKindOfClass:[NSDictionary class]]) {
		return self;
	}

	return self;
}

- (id)initWithCoder:(NSCoder *)decoder {
    NSDictionary *dict = [decoder decodeObjectForKey:@"dict"];

    self = [self initWithDictionary:dict];

    return self;
}

- (void)encodeWithCoder:(NSCoder *)encoder {
    [encoder encodeObject:[self dictionary] forKey:@"dict"];
}

- (NSDictionary*) dictionary {
	NSMutableDictionary * dict = [[NSMutableDictionary alloc] init];

	return dict;
}

@end

// --- PermiessionDeniedResults ---
@implementation ServicePermiessionDeniedResults : NSObject

- (id) initWithDictionary:(NSDictionary*)dict{
	self = [super init];
	if (!self) {
		return self;
	}
	if (![dict isKindOfClass:[NSDictionary class]]) {
		return self;
	}
	[self setErr:[Api errorWithDictionary:[dict valueForKey:@"Err"]]];

	return self;
}

- (id)initWithCoder:(NSCoder *)decoder {
    NSDictionary *dict = [decoder decodeObjectForKey:@"dict"];

    self = [self initWithDictionary:dict];

    return self;
}

- (void)encodeWithCoder:(NSCoder *)encoder {
    [encoder encodeObject:[self dictionary] forKey:@"dict"];
}

- (NSDictionary*) dictionary {
	NSMutableDictionary * dict = [[NSMutableDictionary alloc] init];
	[dict setValue:self.err forKey:@"Err"];

	return dict;
}

@end



@implementation Service : NSObject

- (NSDictionary*) dictionary {
	return [NSDictionary dictionaryWithObjectsAndKeys:nil];
}


// --- Authorize ---
- (ServiceAuthorizeResults *) authorize:(NSString *)name {
	
	ServiceAuthorizeResults *results = [ServiceAuthorizeResults alloc];
	ServiceAuthorizeParams *params = [[ServiceAuthorizeParams alloc] init];
	[params setName:name];
	
	Api * _api = [Api get];
	NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"%@/Service/Authorize.json", [_api baseURL]]];
	if([_api verbose]) {
		NSLog(@"Requesting URL: %@", url);
	}
	NSError *error;
	NSDictionary *paramsDict = @{@"This": [self dictionary], @"Params": [params dictionary]};

	NSDictionary * dict = [Api request:url params:paramsDict stream:nil error:&error completionHandler:nil];

	if(error != nil) {
		if([_api verbose]) {
			NSLog(@"Error: %@", error);
		}
		results = [results init];
		[results setErr:error];
		return results;
	}
	results = [results initWithDictionary: dict];
	
	return results;
}

- (void) authorize:(NSString *)name success:(void (^)(ServiceAuthorizeResults *results))successBlock failure:(void (^)(NSError *error))failureBlock {
	
		ServiceAuthorizeParams *params = [[ServiceAuthorizeParams alloc] init];
		[params setName:name];
		

		Api * _api = [Api get];
		NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"%@/Service/Authorize.json", [_api baseURL]]];
		if([_api verbose]) {
			NSLog(@"Requesting URL: %@", url);
		}
		NSDictionary *paramsDict = @{@"This": [self dictionary], @"Params": [params dictionary]};
		NSError *nilerror = nil;

		[Api request:url params:paramsDict stream:nil error:&nilerror completionHandler:^(NSDictionary *data, NSError *error) {;

			if (error && failureBlock) {
				if([_api verbose]) {
					NSLog(@"Error: %@", error);
				}

				failureBlock(error);
				return;
			}

			ServiceAuthorizeResults *results = [ServiceAuthorizeResults alloc];
			results = [results initWithDictionary: data];

			if (results.err) {
				if([_api verbose]) {
					NSLog(@"Service Error: %@", results.err);
				}

				failureBlock(results.err);
				return;
			}

			if (successBlock) {
				successBlock(results);
			}
		}];
	
}

// --- PermiessionDenied ---
- (NSError *) permiessionDenied {
	
	ServicePermiessionDeniedResults *results = [ServicePermiessionDeniedResults alloc];
	ServicePermiessionDeniedParams *params = [[ServicePermiessionDeniedParams alloc] init];
	
	Api * _api = [Api get];
	NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"%@/Service/PermiessionDenied.json", [_api baseURL]]];
	if([_api verbose]) {
		NSLog(@"Requesting URL: %@", url);
	}
	NSError *error;
	NSDictionary *paramsDict = @{@"This": [self dictionary], @"Params": [params dictionary]};

	NSDictionary * dict = [Api request:url params:paramsDict stream:nil error:&error completionHandler:nil];

	if(error != nil) {
		if([_api verbose]) {
			NSLog(@"Error: %@", error);
		}
		results = [results init];
		[results setErr:error];
		return results.err;
	}
	results = [results initWithDictionary: dict];
	
	return results.err;
}

- (void) permiessionDenied:(void (^)(NSError *error))successBlock failure:(void (^)(NSError *error))failureBlock {
	
		ServicePermiessionDeniedParams *params = [[ServicePermiessionDeniedParams alloc] init];
		

		Api * _api = [Api get];
		NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"%@/Service/PermiessionDenied.json", [_api baseURL]]];
		if([_api verbose]) {
			NSLog(@"Requesting URL: %@", url);
		}
		NSDictionary *paramsDict = @{@"This": [self dictionary], @"Params": [params dictionary]};
		NSError *nilerror = nil;

		[Api request:url params:paramsDict stream:nil error:&nilerror completionHandler:^(NSDictionary *data, NSError *error) {;

			if (error && failureBlock) {
				if([_api verbose]) {
					NSLog(@"Network Error: %@", error);
				}

				failureBlock(error);
				return;
			}

			ServicePermiessionDeniedResults *results = [ServicePermiessionDeniedResults alloc];
			results = [results initWithDictionary: data];

			if (results.err) {
				if([_api verbose]) {
					NSLog(@"Service Error: %@", results.err);
				}

				failureBlock(results.err);
				return;
			}

			if (successBlock) {
				successBlock(results.err);
			}
		}];
	
}
@end

