{{define "golang/interface"}}// Generated by github.com/hypermusk/hypermusk
// DO NOT EDIT
{{$pkg := .}}package client

import ({{range .ServerImports}}
	"{{.}}"{{end}}
)

{{$errorTypeName := "SerializableError"}}

var ApiDomain string
func ToJson(v interface{}) (r []byte) {
	r, _ = json.Marshal(v)
	return
}

func printStackAndError(err error) {
	log.Printf("********** Debug Error message: %+v ***********\n", err)
	debug.PrintStack()
}


type {{$errorTypeName}} struct {
	Message string
	Code    string
	Reason  govalidations.Validated
}

func (this *{{$errorTypeName}}) toError() (err error) {

	if this == nil {
		return
	}

	err = this.Reason.ToError()
	if err == nil && this.Message != "" {
		err = errors.New(this.Message)
	}

	return
}


{{range .Interfaces}}{{$interface := .}}
{{with .Constructor}}type {{$interface.Name | title}} struct {
	{{range .Method.Params}}{{.Name | title}} {{.FullGoTypeName}}
{{end}}}{{end}}
{{with .Constructor}}
{{else}}
	type {{$interface.Name | title}} struct{}
	var Default{{$interface.Name | title}} = &{{$interface.Name | title}}{}
{{end}}
{{range .Methods}}{{$method := .}}
	{{if .ConstructorForInterface}}
	func (this *{{$interface.Name | title}}) {{$method.Name}}({{$method.ParamsForGoClientFunction}}) ({{$method.ResultsForGoClientFunction}}){
	{{.ConstructorForInterface.Name | snake}} = &{{.ConstructorForInterface.Name | title}}{
		{{range $method.Params}}{{.Name | title}}: {{.Name | snake}},
		{{end}}}
	return
	}
	{{else}}
		type {{$interface.Name | snake}}_{{$method.Name}}_Results struct {
			{{range .Results}}{{ if eq .FullGoTypeName "error" }}{{.Name | title}} {{$errorTypeName}}{{ else }}{{.Name | title}} {{.FullGoTypeName}}{{ end }}
			{{end}}
		}

		func (this *{{$interface.Name | title}}) {{$method.Name}}({{$method.ParamsForGoClientFunction}}) ({{$method.ResultsForGoClientFunction}}){
			bodyMap := make(map[string]interface{})
			bodyMap["This"] = this
			{{if $method.Params}}paramsMap := make(map[string]interface{})
			{{range $method.Params}}paramsMap["{{.Name | title}}"] = {{.Name}}
			{{end}}bodyMap["Params"] = paramsMap{{end}}

			client := new(http.Client)
			request, err := http.NewRequest("POST", ApiDomain+"/{{$interface.Name}}/{{.Name}}.json", bytes.NewReader(ToJson(bodyMap)))
			request.Header.Add("Accept-Encoding", "gzip")

			response, err := client.Do(request)
			if err != nil {
				printStackAndError(err)
				return
			}

			if response == nil || response.Body == nil {
				return
			}
			defer response.Body.Close()

			if response.StatusCode >= 300 {
				err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
				return
			}

			// Check that the server actually sent compressed data
			var reader io.ReadCloser
			switch response.Header.Get("Content-Encoding") {
			case "gzip":
				reader, err = gzip.NewReader(response.Body)
			default:
				reader = response.Body
			}

			var result {{$interface.Name | snake}}_{{$method.Name}}_Results
			dec := json.NewDecoder(reader)
			if e := dec.Decode(&result); e != nil {
				printStackAndError(e)
				// No return
			}
			{{range $i ,$r := $method.Results}}
			{{$titleName := title .Name}}
			{{if eq $titleName "Err"}}
				err = result.Err.toError()
			{{else}}
				{{.Name | snake}} = result.{{.Name | title}}
			{{end}}
			{{end}}
			return
		}{{end}}
{{end}}
{{end}}
{{end}}
